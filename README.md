### frame
FindFirstNonrepeatWord  
|-----findx: 处理文本  
|-----tests: 测试文件  
|-----Util: 工具
### usage
1. 运行main.go,会自动在当前目录下生成text文件夹以及smallText文件夹，其中text是100G文件，smalltext中是分割后的小文件，main.go会在终端打印100G文本文件中，第一个不重复的字符串。  

### env：
1. os: win10 pro
2. golang 1.12.9

### analysis
1. 每行一个词，根据txt文件格式，一行最多能容纳1024个字符，除去换行符，每行字符串的长度范围为[0, 1022]
2. 原文件不可能一次性加载进内存中进行处理，需要将文件分割成小文件，对原文件中的字符进行hash,存到不同的小文件中，相同的字符串应当散列到相同的文件当中。
3. 原文件在处理的过程中，可以利用一个hashmap进行小文件的重复词条的写入优化，hashmap保存词条以及当前出现的次数，当发现某个词条在hashmap中已经有两次记录了，我们就不把当前词条写入相应的小文件中（小文件中已经有两个相同词条，能保证筛选正确性）。由于内存有限，hashmap大小需要设置上限，haspmap到达上限后，对于之前未记录的词条，我们不再利用hashmap做优化，直接写入相应的小文件中。
4. 关于大文件需要分割成多少份小文件，小文件进行处理的时候，内存中的数据包括小文件的所有词条以及相应的频率和大文件中的位置，考虑最极端的情况，应满足等式：$$\cfrac{100}{x} + \cfrac{100}{3x}*(8+8) < 16$$
5. 大文件分割出来的小文件可能存在大小超过上面计算出来的$x$,对此，我们要重新分割小文件。
5. 由于要找到第一个不重复的词，小文件中不仅仅要保存字符串的原文，还需要记录字符串在原文件中的位置(line),原文件的行数范围在[100M, 100G/3(每行最小长度：空字符串加上换行符)]
6. 对小文件进行处理，读入内存当中，利用一个hash表记录字符串和相应的频率和位置。将小文件当中的内容全部读取完毕以后，遍历一遍，找到序号最小并且只出现了
一次的字符串。